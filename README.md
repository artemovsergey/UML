# Функциональное и объектно-ориентированное проектирование

## UML

Язык UML представляет собой общецелевой язык визуального моделирования, который разработан для
спецификации, визуализации, проектирования и документирования компонентов программного обеспечения, бизнес-процессов и других систем.

Язык UML одновременно является простым и мощным средством моделирования, который может быть
эффективно использован для построения концептуальных, логических и графических моделей сложных систем самого различного целевого назначения.

В языке UML используется четыре основных вида графических конструкций:
‒ Значки или пиктограммы. Значок представляет собой графическую фигуру фиксированного размера и
формы. Примерами значков могут служить окончания связей элементов диаграмм или некоторые другие
дополнительные обозначения.
‒ Графические символы на плоскости. Такие двумерные символы изображаются с помощью некоторых
геометрических фигур и могут иметь различную высоту и ширину с целью размещения внутри этих фигур других конструкций языка UML.
Наиболее часто внутри таких символов помещаются строки текста, которые уточняют семантику или
фиксируют отдельные свойства соответствующих элементов языка UML. Информация, содержащаяся внутри
фигур, имеет важное значение для конкретной модели проектируемой системы, поскольку регламентирует реализацию соответствующих элементов в программном коде.

‒ Пути, которые представляют собой последовательности из отрезков линий, соединяющих отдельные
графические символы. При этом концевые точки отрезков линий должны обязательно соприкасаться с
геометрическими фигурами, служащими для обозначения вершин диаграмм, как принято в теории графов. С концептуальной точки зрения путям в языке UML придается особое значение, поскольку они являются простыми топологическими сущностями.

‒ Строки текста. Служат для представления различных видов информации в некоторой грамматической
форме. Предполагается, что каждое использование строки текста должно соответствовать синтаксису в нотации языка UML, посредством которого может быть реализован грамматический разбор этой строки.
При графическом изображении диаграмм следует придерживаться следующих основных рекомендаций:
1. Каждая диаграмма должна служить законченным представлением соответствующего фрагмента
моделируемой предметной области.
2. Все сущности на диаграмме модели должны быть одного концептуального уровня. Здесь имеется в виду согласованность не только имен одинаковых элементов, но и возможность вложения отдельных диаграмм друг в друга для достижения полноты представлений.
3. Вся информация о сущностях должна быть явно представлена на диаграммах. Речь идет о том, что, хотя в языке UML при отсутствии некоторых символов на диаграмме могут быть использованы их значения по умолчанию (например, в случае неявного указания видимости атрибутов и операций классов), необходимо стремиться к явному указанию свойств всех элементов диаграмм.
4. Диаграммы не должны содержать противоречивой информации. Противоречивость модели может служить
причиной серьезнейших проблем при ее реализации и последующем использовании на практике. Например, наличие замкнутых путей при изображении отношений агрегирования или композиции приводит к ошибкам в программном коде, который будет реализовывать соответствующие классы. Наличие элементов с одинаковыми именами и различными атрибутами свойств в одном пространстве имен также приводит к неоднозначной интерпретации и может служить источником проблем.
5. Диаграммы не следует перегружать текстовой информацией. Принято считать, что визуализация модели является наиболее эффективной, если она содержит минимум пояснительного текста.
6. Каждая диаграмма должна быть самодостаточной для правильной интерпретации всех ее элементов и
понимания семантики всех используемых графических символов.
7. Количество типов диаграмм для конкретной модели приложения не является строго фиксированным.



## Анализ предметной области и проектирование

Анализ предметной области и проектирование являются первыми этапами в жизненном цикле создания программного решения.
Одним из результатов этого этапа является диаграмма вариантов использования (Use Case), описывающая основные группы пользователей системы и варианты ее использования.

**Предметная область** — это часть реального мира, данные и особенности которой будут отражены в разрабатываемом программном решении. 
Предметная область бесконечна и содержит как важные понятия и данные, так и малозначащие или вообще ничего не значащие данные.

## Hot Keys для Visio
Горячие клавиши (Hot Keys) для переключения инструментов
Ctrl + 1 — выделить элемент
Ctrl + 2 — добавить комментарий
Ctrl + 3 — добавить связь между актером и прецедентом

## Разграничение прецедентов между актерами и размещение отношений
**Отношение ассоциации** — отражает возможность использования актером прецедента
**Отношение включения** — поведение одного прецедента включается в другой в качестве составного, причем дополняемый вариант использования не сможет выполняться без основного

**Отношение расширения** — отражает возможное присоединение одного использования к другому, при этом расширяющий вариант использования выполняется лишь при определенных условиях и не является обязательным для выполнения основного прецедента

**Пример**
![UseCase](https://user-images.githubusercontent.com/26972859/166151147-1c5adec2-f317-4c96-8d2c-557997504381.png)


Разработка диаграммы вариантов использования преследует цели:
1. Определить общие границы и контекст моделируемой предметной области на начальных этапах
проектирования системы.
2. Сформулировать общие требования к функциональному поведению проектируемой системы.
3. Разработать исходную концептуальную модель системы для ее последующей детализации в форме
логических и физических моделей.
4. Подготовить исходную документацию для взаимодействия разработчиков системы с ее заказчиками и
пользователями.
Суть данной диаграммы состоит в следующем: проектируемая система представляется в виде множества
сущностей или актеров, взаимодействующих с системой с помощью так называемых вариантов использования.
При этом актером (actor) или действующим лицом называется любая сущность, взаимодействующая с
системой извне. Это может быть человек, техническое устройство, программа или любая другая система, которая
может служить источником воздействия на моделируемую систему так, как определит сам разработчик.
В свою очередь, вариант использования (usecase) служит для описания сервисов, которые система
предоставляет актеру. Другими словами, каждый вариант использования определяет некоторый набор действий,
совершаемый системой при диалоге с актером. При этом ничего не говорится о том, каким образом будет
реализовано взаимодействие актеров с системой.
В самом общем случае, диаграмма вариантов использования представляет собой граф специального вида,
который является графической нотацией для представления конкретных вариантов использования, актеров,
возможно некоторых интерфейсов, и отношений между этими элементами.
Вариант использования (use case) – конструкция или стандартный элемент языка UML, который
применяется для спецификации общих особенностей поведения системы или любой другой сущности предметной
области без рассмотрения внутренней структуры этой сущности. Каждый вариант использования определяет
последовательность действий, которые должны быть выполнены проектируемой системой при взаимодействии ее
с соответствующим актером.
Диаграмма вариантов может дополняться пояснительным текстом, который раскрывает смысл или семантику
составляющих ее компонентов.
Такой пояснительный текст получил название примечания или сценария.
Отдельный вариант использования обозначается на диаграмме эллипсом, внутри которого содержится
его краткое название или имя в форме глагола с пояснительными словами.

Актер (actor) представляет собой любую внешнюю по отношению к моделируемой системе сущность,
которая взаимодействует с системой и использует ее функциональные возможности для достижения определенных целей или решения частных задач. При этом актеры служат для обозначения согласованного множества ролей, которые могут играть пользователи в процессе взаимодействия с проектируемой системой. Каждый актер может рассматриваться как некая отдельная роль относительно конкретного варианта использования. Стандартным графическим обозначением актера на диаграммах является фигурка «человечка», под которой записывается конкретное имя актера.

Интерфейс (interface) служит для спецификации параметров модели, которые видимы извне без указания их внутренней структуры. В языке UML интерфейс является классификатором и характеризует только ограниченную часть поведения моделируемой сущности. Применительно к диаграммам вариантов использования, интерфейсы определяют совокупность операций, которые обеспечивают необходимый набор сервисов или функциональности для актеров. Интерфейсы не могут содержать ни атрибутов, ни состояний, ни направленных ассоциаций. Они содержат только операции без указания особенностей их реализации.

На диаграмме вариантов использования интерфейс изображается в виде маленького круга, рядом с которым записывается его имя.

В качестве имени может быть существительное, которое характеризует соответствующую информацию или
сервис (например, «датчик», «сирена», «видеокамера»), но чаще строка текста (например, «запрос к базе данных», «форма ввода», «устройство подачи звукового сигнала»).
Если имя записывается на английском, то оно должно начинаться с заглавной буквы I, например,
ISecurelnformation, ISensor.
Графический символ отдельного интерфейса может соединяться на диаграмме сплошной линией с тем
вариантом использования, который его поддерживает. Сплошная линия в этом случае указывает на тот факт, что связанный с интерфейсом вариант использования должен реализовывать все операции, необходимые для данного интерфейса, а возможно и больше.
Кроме этого, интерфейсы могут соединяться с вариантами использования пунктирной линией со стрелкой, означающей, что вариант использования предназначен для спецификации только того сервиса, который необходим для реализации данного интерфейса.

Примечания (notes) в языке UML предназначены для включения в модель произвольной текстовой
информации, имеющей непосредственное отношение к контексту разрабатываемого проекта. В качестве такой информации могут быть комментарии разработчика (например, дата и версия разработки диаграммы или ее отдельных компонентов), ограничения (например, на значения отдельных связей или экземпляры сущностей) и помеченные значения. Применительно к диаграммам вариантов использования примечание может носить самую общую информацию, относящуюся к общему контексту системы.
Графически примечания обозначаются прямоугольником с «загнутым» верхним правым уголком.

Внутри прямоугольника содержится текст примечания. Примечание может относиться к любому элементу
диаграммы, в этом случае их соединяет пунктирная линия. Если примечание относится к нескольким элементам, то от него проводятся, соответственно, несколько линий. Разумеется, примечания могут присутствовать не только на диаграмме вариантов использования, но и на других канонических диаграммах.

## Отношения на диаграмме вариантов использования

Между компонентами диаграммы вариантов использования могут существовать различные отношения,
которые описывают взаимодействие экземпляров одних актеров и вариантов использования с экземплярами других актеров и вариантов.

Один актер может взаимодействовать с несколькими вариантами использования. В этом случае этот актер обращается к нескольким сервисам данной системы. В свою очередь один вариант использования может взаимодействовать с несколькими актерами, предоставляя для всех них свой сервис. Следует заметить, что два варианта использования, определенные для одной и той же сущности, не могут взаимодействовать друг с другом, поскольку каждый из них самостоятельно описывает законченный вариант использования этой сущности. Более того, варианты использования всегда предусматривают некоторые сигналы или сообщения, когда взаимодействуют с актерами за пределами системы. В то же время могут быть определены другие способы для взаимодействия с элементами внутри системы.

В языке UML имеется несколько стандартных видов отношений между актерами и вариантами
использования:
1. Отношение ассоциации (association relationship)
Отношение ассоциации является одним из фундаментальных понятий в языке UML и в той или иной степени
используется при построении всех графических моделей систем в форме канонических диаграмм.
Применительно к диаграммам вариантов использования оно служит для обозначения специфической роли
актера в отдельном варианте использования. Другими словами, ассоциация специфицирует семантические
особенности взаимодействия актеров и вариантов использования в графической модели системы. Таким образом,
это отношение устанавливает, какую конкретную роль играет актер при взаимодействии с экземпляром варианта
использования. На диаграмме вариантов использования, так же, как и на других диаграммах, отношение
ассоциации обозначается сплошной линией между актером и вариантом использования. Эта линия может иметь
дополнительные условные обозначения, такие, например, как имя и кратность (рис. 6).

Отношение расширения (extend relationship)
Отношение расширения определяет взаимосвязь экземпляров отдельного варианта использования с более
общим вариантом, свойства которого определяются на основе способа совместного объединения данных
экземпляров.
Так, если имеет место отношение расширения от варианта использования А к варианту использования В, то
это означает, что свойства экземпляра варианта использования В могут быть дополнены благодаря наличию
свойств у расширенного варианта использования А.
Отношение расширения между вариантами использования обозначается пунктирной линией со стрелкой
(вариант отношения зависимости), направленной от того варианта использования, который является расширением
для исходного варианта использования. Данная линия со стрелкой помечается ключевым словом «extend»
(«расширяет»).
Отношение расширения отмечает тот факт, что один из вариантов использования может присоединять к
своему поведению некоторое дополнительное поведение, определенное для другого варианта использования.
Один из вариантов использования может быть расширением для нескольких базовых вариантов, а также иметь
в качестве собственных расширений несколько других вариантов. Базовый вариант использования может
дополнительно никак не зависеть от своих расширений.

3. Отношение обобщения (generalization relationship)
Отношение обобщения служит для указания того факта, что некоторый вариант использования А может быть
обобщен до варианта использования В.
В этом случае вариант А будет являться специализацией варианта В. При этом В называется предком или
родителем по отношению А, а вариант А – потомком по отношению к варианту использования В. Следует
подчеркнуть, что потомок наследует все свойства и поведение своего родителя, а также может быть дополнен
новыми свойствами и особенностями поведения.
Графически данное отношение обозначается сплошной линией со стрелкой в форме незакрашенного
треугольника, которая указывает на родительский вариант использования (рис. 8). Эта линия со стрелкой имеет
специальное название – стрелка «обобщение».
Рисунок 90 – Графическое обозначение отношения обобщения
Отношение обобщения между вариантами использования применяется в том случае, когда необходимо
отметить, что дочерние варианты использования обладают всеми атрибутами и особенностями поведения
родительских вариантов. При этом дочерние варианты использования участвуют во всех отношениях
родительских вариантов. В свою очередь, дочерние варианты могут наделяться новыми свойствами поведения,
которые отсутствуют у родительских вариантов использования, а также уточнять или модифицировать
наследуемые от них свойства поведения.
Между отдельными актерами также может существовать отношение обобщения. Данное отношение является
направленным и указывает на факт специализации одних актеров относительно других. Например, отношение
обобщения от актера А к актеру В отмечает тот факт, что каждый экземпляр актера А является одновременно
экземпляром актера В и обладает всеми его свойствами. В этом случае актер В является родителем по отношению
к актеру А, а актер А, соответственно, потомком актера В. При этом актер А обладает способностью играть такое
же множество ролей, что и актер В.
Графически данное отношение также обозначается стрелкой обобщения, т. е. сплошной линией со стрелкой в
форме незакрашенного треугольника, которая указывает на родительского актера.

4. Отношение включения (include relationship)
Отношение включения между двумя вариантами использования указывает, что некоторое заданное поведение
для одного варианта использования включается в качестве составного компонента последовательность поведения
другого варианта использования. Данное отношение является направленным бинарным отношением в том смысле,
что пара экземпляров вариантов использования всегда упорядочена в отношении включения.
Отношение включения, направленное от варианта использования А к варианту использования В, указывает,
что каждый экземпляр варианта А включает в себя функциональные свойства, заданные для варианта В. Эти
свойства специализируют поведение соответствующего варианта А на данной диаграмме. Графически данное
отношение обозначается пунктирной линией со стрелкой (вариант отношения зависимости), направленной от
базового варианта использования к включаемому. При этом данная линия со стрелкой помечается ключевым
словом «include» («включает»).




## Проектирование ER-диаграммы в MS Visio
В данном пункте займемся проектированием ER-диаграммы или диаграммы «сущность-связь», разберем разные типы связей и визуализируем их на примере.
В основе ER-диаграмм лежит принцип «рисунок нагляднее текста». ER-диаграмма графически представляет сущности (entities) предметной области, свойства (attributes) сущностей и связи (relationship) между ними. ER-диаграммы делятся на концептуальные и физические. В отличие от физических, в концептуальных ER-диаграммах не учитываются особенности конкретной базы данных. Впоследствии сущности концептуальных ER-диаграмм становятся таблицами, атрибуты — колонками, а связи реализуются путем миграции ключевых атрибутов родительских сущностей и создания внешних ключей.
	Пример построения ER-диаграммы
	Предметная область — фитнес-индустрия. Цель заказчика — разработка платформы для удаленных тренировок. 
Основные шаги построения ER-диаграммы:
•	Добавление сущностей
•	Добавление связей и их настройка
•	Добавление атрибутов
В данной дипломной работе ER-диаграмма составляется в Microsoft Visio на основе описания заказчика. Используется тип диаграммы Crow's Food database notation.
Сущность (entity) — класс реальных или виртуальных однотипных объектов, информацию о которых необходимо хранить в базе данных. Пример сущности — «тренер». На ER-диаграмме сущность изображается в виде прямоугольника, внутри которого содержится имя сущности в форме существительного в единственном числе. Связь (relationship) — ассоциация между сущностями. Для облегчения понимания диаграммы следует добавлять названия связей. Пример связи — «тренер получает заявку».
Далее укажем тип связи между сущностями. При определении типа следует учитывать модальность связи: «может» или «должен». Модальность «может» означает, что экземпляр одной сущности может быть связан с одним или несколькими экземплярами другой сущности, а может быть и не связан ни с одним экземпляром другой сущности. Модальность «должен» подразумевает связь не менее чем с одним экземпляром другой сущности. Примеры возможных типов связей представлены в таблице



Атрибуты предназначены для описания сущности. Следует учитывать, что не все атрибуты могут быть указаны явно в техническом задании. Например, для определения стажа тренера удобно хранить в базе данных дату его трудоустройства.
Ключ — это один или несколько атрибутов, уникально определяющих сущность. В данном примере в качестве ключа используется атрибут «код».

![Erd](https://user-images.githubusercontent.com/26972859/166198899-b92f22f9-69dd-4fab-8823-9288a82ebc2c.png)

**Замечание**: на Erd диаграмме надо указать модальность связи (может-должен), кратность связи (1:M, M:M). Также указать идентифицирующая или неидентифицирующая связь.



## Проектирование диаграмм классов UML (CLASS DIAGRAM)
Унифицированный язык моделирования (UML)
UML — унифицированный язык графических нотаций, в основе которого лежит единая метамодель.
UML используется для описания и проектирования программных систем, особенно построенных с использованием объектно-ориентированных (ОО) технологий.
UML как средство проектирования нацелен на полноту. Используя UML, дизайнер может строить детальные модели для программиста, который далее выполняет кодирование без глубокого погружения в детали
Диаграмма классов описывает типы объектов системы и различного рода статические отношения, которые существуют между ними. На диаграммах классов отображаются также **свойства классов**, **операции классов** и **ограничения**, которые накладываются на связи между объектами
Классы могут представлять сущности предметной области (на этапе анализа) или элементы программной системы (на этапе проектирования и реализации).

На диаграмме класс изображается в виде прямоугольника, разделенного на три части: **имя класса** (на английском языке), его **атрибуты** и его **операции**. В качестве классов выступают сущности, использованные при построении диаграммы сущность-связь.
В данном примере добавляется объект «role» типа «перечисление» (англ. enumeration), представляющий собой набор логически связанных и заранее присвоенных значений (Client, Trainer, Admin)

![enumeration](https://user-images.githubusercontent.com/26972859/166207725-1c106e81-8ebd-48ab-bd75-1477405f89ac.png)

**Ассоциация** является одним из двух основных типов связи на диаграмме классов, показывающим, что можно перемещаться между объектами двух связанных классов. Пример ассоциации — «Trainer-TrainingCourse»

![Association](https://user-images.githubusercontent.com/26972859/166208022-2699752e-21e3-4c3e-af46-2e95223da9f0.png)

**Композиция** — частный случай ассоциации, представляющий собой отношение типа «часть-целое». Композиция имеет четко выраженные отношения владения, а также характеризуется _совпадением времени жизни части и целого_. Композиция имеет жесткую зависимость времени существования экземпляров класса контейнера и экземпляров содержащихся классов. Если контейнер будет уничтожен, то все его содержимое будет также уничтожено. Пример композиции — связь «TrainingPlan-PersonalTraining»

![Composition](https://user-images.githubusercontent.com/26972859/166208383-240429df-6b3d-4fc2-867b-ca39fb1a17cf.png)


**Кратность** связи или множественность ассоциации — диапазон целых чисел, указывающий возможное количество связанных объектов. Кратность задается путем указания минимального и максимального количества объектов, разделенных двумя точками. Варианты кратности связи: 1 (единица), 0.1 (ноль или один), 0.* (любое значение) и 1.* (один или несколько).

![Кратность](https://user-images.githubusercontent.com/26972859/166209288-494d146c-b55a-418c-b58a-e1703ac06856.png)

**Наследование** (inheritance) — отношение типа «общее-частное», при котором один класс обладает поведением и структурой ряда других классов. Пример наследования — связь «Trainer-User».

![Inherence](https://user-images.githubusercontent.com/26972859/166209541-8f1bb3c2-c7ba-4f64-ac2f-8de41dcfdae4.png)


**Атрибут** описывает свойство класса в виде строки текста, имеющей в общем случае следующую структуру: «visibility name: type = defaultValue», где visibility определяет область видимости (public, private или protected), name есть имя атрибута, type определяет тип атрибута, а defaultValue — его значение по умолчанию (для числовых или булевых переменных).
	


В **заметках** можно указывать ограничения. В данном примере добавляется следующее ограничение: если заявка не принята, то должна быть указана причина.
	
![Note](https://user-images.githubusercontent.com/26972859/166210026-7c81b941-37a0-436a-b57a-080cbc951d29.png)
	
Операции — действия, реализуемые некоторым классом, т. е. по сути **методы класса**. Общая форма записи операции: visibility name (parameter-list): return-type-expression, т. е. область видимости, имя операции, список параметров, тип возвращаемого значения.

Диаграмма классов является одной из канонических диаграмм UML, создаваемой для визуализации
структурированной статической модели предметной области. Этот вид диаграмм представляет собой графическое изображение объектов – классов с присущими им атрибутами, операциями и различных отношений между классами.

Класс (class) служит для обозначения множества объектов, обладающих функциональным набором одинаково описывающих параметров (атрибутов), реализуемых операций и однотипными отношениями с объектами других классов.

На диаграмме класс изображается габаритной прямоугольной рамкой, которая дополнительно может быть
разделена горизонтальными линиями на секции, каждая из которых предназначена для указания имени, атрибутов (свойств) и реализуемых операций объектов данного класса.


Имя класса является обязательным элементом в его обозначении и должно быть уникальным (хотя бы в
пределах пакета), имеющее непосредственное отношение к контексту моделируемой предметной области.
В соответствии с принятым в языке UML общим соглашением в качестве имени класса используются
существительные и прилагательные, каждое из которых начинается с заглавной буквы, записанные без пробелов.
Например, в качестве имен классов могут быть использованы профессиональные термины: «Сотрудник»,
«Компания», «Руководитель», «Клиент», «Продавец», «Менеджер», «Офис», «Покупатель»,
«Датчик_Температуры» и др. Такое имена классов являются простыми.
Иногда возникает необходимость в явном указании пакета, к которому относится данный класс. С этой целью в условном обозначении перед именем класса указывается имя пакета и специальный символ разделитель – двойное двоеточие "::". Такое имя класса является квалифицированным. Текстовая строка имени класса в этом случае записывается в формате <Имя_пакета>::<Имя_класса>.


## Атрибуты классов

Содержательной характеристикой класса является атрибут, содержащий множество значений, которые могут
принимать отдельные объекты этого класса. При этом, класс может иметь любое число атрибутов или не иметь ни
одного. Так, например, атрибутами класса «Усилитель» являются частотный диапазон, выходная мощность,
коэффициент нелинейных искажений, уровень шума и т. д.

Запись атрибута также представляет собой отдельную строку текста, содержащую обязательное имя, в
котором обычно каждое слово пишется с заглавной буквы, за исключением первого, например, name (имя) или
birth_Date (дата_Рождения).
Например, на рис. 3 указаны атрибуты класса Контейнер, в качестве которых выступают атрибут
тип_Контейнера, атрибут регистрационный_Номер_Контейнера,
регистрационный_Номер_После_Перерегистрации, рабочее_Состояние.

Качественной характеристикой описания элементов класса является квантор видимости атрибута –
потенциальная возможность других объектов модели оказывать влияние на отдельные аспекты поведения данного
класса.
Эта характеристика может принимать одно из трех возможных значений и, соответственно, отображается при
помощи специальных символов: символ "+" (public) обозначает атрибут с областью видимости типа
общедоступный; атрибут с этой областью видимости доступен или виден из любого другого класса пакета, в
котором определена диаграмма; например, для класса Class_1 указан атрибут общедоступного типа (рис. 4а);
символ "#" (protected) обозначает атрибут с областью видимости типа защищенный; атрибут с этой областью
видимости недоступен или невиден для всех классов, за исключением подклассов данного класса; например, для
класса Class_2 указан атрибут защищенного типа (рис. 4б); символ "-" (private) обозначает атрибут с областью
видимости типа закрытый; атрибут с этой областью видимости недоступен или невиден для всех классов без
исключения; например, для класса Class_3 указан атрибут защищенного типа (рис. 4в);
Квантор видимости при описании атрибутов может быть опущен, что будет означать тот факт, что видимость
атрибута не указывается.

## Операции классов

Операция (operation) класса – это реализация услуги, которая может быть запрошена у любого объекта данного
класса, чтобы вызвать определенное его поведение. Класс может иметь любое число операций либо не иметь ни
одной. Так автомобиль может перемещаться по грунту, корабль – перемещаться по воде, компьютер – производить
вычисления.
Представление полного синтаксиса записи операций класса также подчиняется определенным
синтаксическим правилам: каждой операции класса соответствует отдельная строка, которая состоит из квантора
видимости операции, обязательного имени операции, выражения типа возвращаемого операцией значения и,
возможно, строки-свойства данной операции:
< квантор видимости >< имя операции > (список параметров) : < выражение типа возвращаемого значения
>{строка-свойство}
Квантор видимости, как и в случае атрибутов класса, может принимать одно из трех возможных значений и,
соответственно, также отображается при помощи специального символа.
Для именования операции используются короткие глагольные конструкции, описывающие некоторое
поведение класса, которому принадлежит операция. Обычно каждое слово в имени операции пишется с заглавной
буквы, за исключением первого.

Например, запись +создать() – может обозначать абстрактную операцию по созданию отдельного объекта
класса, которая является общедоступной и не содержит формальных параметров, запись +нарисовать(форма:
Многоугольник = прямоугольник, цвет_заливки: Color = (О, О, 255)) – может обозначать операцию по
изображению на экране монитора прямоугольной области синего цвета, если не указываются другие значения в
качестве аргументов данной операции.
(список–параметров) содержит необязательные аргументы, синтаксис которых совпадает с синтаксисом
атрибутов;
< выражение типа возвращаемого значения > является необязательной спецификацией и зависит от
конкретного языка программирования;
{строка-свойство} показывает значения свойств, которые применяются к данной операции.
Например, запись запросить_Cчет_Клиента(номер_счета:Integer) – обозначает операцию по установлению
наличия средств на текущем счете клиента банка. При этом аргументом данной операции является номер счета
клиента, который записывается в виде целого числа (например, «123456»).

Квантор видимости для операции может быть опущен. В этом случае его отсутствие означает, что видимость
операции не указывается.

## Отношения между классами

Классы на диаграмме связываются различными типами отношений. При этом совокупность типов таких
отношений фиксирована в языке UML и предопределена их семантикой.
3.4.1. Отношение зависимости
Отношением зависимости (dependency relationship) называют связь по использованию, когда изменение в
спецификации одного класса может повлиять на поведение другого. Отношение зависимости используется в такой
ситуации, когда некоторое изменение одного элемента модели может потребовать изменения другого зависимого
от него элемента модели. Отношение зависимости графически изображается пунктирной линией между
соответствующими элементами со стрелкой на одном из ее концов, направленной к той сущности, от которой
зависит данная сущность. Например, некая сущность Класс_2 использует другую сущность Класс_1 (рис. 6).

В качестве класса-клиента и класса-источника зависимости может выступать множество элементов модели. В
этом случае одна линия со стрелкой, выходящая от источника зависимости, расщепляется в некоторой точке на
несколько отдельных линий, каждая из которых имеет отдельную стрелку для класса-клиента.
Например, если функционирование сущности Класс_С зависит от особенностей реализации сущностей
Класс_А и Класс_Б, то данная зависимость может быть изображена следующим образом (рис. 7).

 Отношение ассоциации
Ассоциацией (association relationship) называется структурная связь, показывающая, что объекты одного
класса некоторым образом связаны с объектами другого или того же самого класса.
Ассоциация может отображаться графически линией со стрелкой (маркером в виде треугольника),
показывающей направление следования классов и кратность – количество объектов, связанных отношением.
Отсутствие стрелки рядом с именем ассоциации означает, что порядок следования классов в рассматриваемом
отношении не определен (рис. 8).

Так, в примере на рис. 8 кратность «1» для класса «Компания» означает, что каждый сотрудник может работать
только в одной компании. Кратность «1..*» для класса «Сотрудник» означает, что в каждой компании могут
работать несколько сотрудников, общее число которых заранее неизвестно и ничем не ограничено.
Специальной формой или частным случаем отношения ассоциации является отношение агрегации, которое, в
свою очередь, тоже имеет специальную форму – отношение композиции (см. пункт 3.4.4).
3.4.3. Отношение агрегации
Отношение агрегации (generalization relationship) имеет место между несколькими классами в том случае,
если один из классов представляет собой некоторую сущность, включающую в себя в качестве составных частей
другие сущности.
Данное отношение имеет фундаментальное значение для описания структуры сложных систем, поскольку
применяется для представления системных взаимосвязей типа «часть – целое».
Это отношение по своей сути описывает декомпозицию или разбиение сложной системы на более простые
составные части, которые также могут быть подвергнуты декомпозиции, если в этом возникнет необходимость в
последующем.
Так, автомобиль состоит из кузова, двигателя, трансмиссии и т.п., а в состав приемопередающего устройства
входят передатчик, приемник и антенно-фидерное устройство.
Графически отношение агрегации изображается сплошной линией, один из концов которой представляет
собой геометрическую фигуру – ромб. Этот ромб указывает на тот из классов, который представляет собой «целое»
(рис. 9).

Примером отношения агрегации может служить деление класса Аналитическая_информация на составные
части: Отчет_по_грузу, Отчет_по_контейнерам, Отчет_по_тарифам (рис. 10).

Отношение агрегации обладает кратностью. Так, класс Система_обеспечения_безопасности_объектов может
содержать содержит одну подсистему Сопровождение_грузов, которая в свою очередь может содержать,
например, четыре класса Охрана_вооруженная, каждый из которых может принадлежать лишь одному классу
Сопровождение_грузов (рис. 11).

4. Отношение композиции
Отношение композиции (realization relationship) служит для выделения специальной формы отношения
«часть-целое», при которой составляющие части в некотором смысле находятся внутри целого.
Специфика взаимосвязи между ними заключается в том, что части не могут выступать в отрыве от целого, т.
е. с уничтожением целого уничтожаются и все его составные части.
Графически отношение композиции изображается сплошной линией, один из концов которой представляет
собой закрашенный внутри ромб. Этот ромб указывает на тот из классов, который представляет собой класскомпозицию или «целое» (рис. 12).
Применительно к классу Заказ_на_перевозку_грузов отношение композиции может иметь следующий вид
(рис. 13).

Отношение обобщения
Отношение обобщения (генерализация) является обычным таксономическим отношением между более
общим элементом (класс-предок) и более частным или специальным элементом (класс-потомок).
Применительно к диаграмме классов данное отношение описывает иерархическое строение классов и
наследование их свойств и поведения. При этом предполагается, что класс-потомок обладает всеми свойствами и
поведением класса-предка, а также имеет свои собственные свойства и поведение, которые отсутствуют у классапредка.
На диаграммах отношение обобщения обозначается сплошной линией с треугольной стрелкой на одном из
концов, направленной на более общий класс (класс-предок или суперкласс) от более специального класса (классапотомка или подкласса) (рис. 14).
Как правило, на диаграмме может указываться несколько линий для одного отношения обобщения, что
отражает его таксономический характер. В этом случае более общий класс разбивается на подклассы одним
отношением обобщения, например, так, как показано на рис. 14.
В этом случае данные отдельные линии изображаются сходящимися к единственной стрелке, имеющей с ними
общую точку пересечения. Родительский Класс Отчет_По_Заказам_На_Перевозку имеет три потомка
Отчет_По_Количеству_Заказов, Отчет_По_Клиентам, Отчет_За_Период, которые наследуют структуру и
поведение родительского класса.

Для связей обобщения язык UML содержит ограничения. В большинстве случаев ограничение размещается
рядом с элементом и заключается в фигурные скобки, например {complete}.
В качестве ограничений могут быть использованы следующие ключевые слова языка UML:
1. {complete} означает, что в данном отношении обобщения специфицированы все классы-потомки, и других
классов-потомков у данного класса-предка быть не может.
Например, класс Клиент_банка является предком для двух классов: Физическое_лицо и Компания, и других
классов-потомков он не имеет.
На соответствующей диаграмме классов это можно указать явно, записав рядом с линией обобщения данную
строку-ограничение (рис. 15).
2. {incomplete} означает тот факт, что на диаграмме указаны в обобщении не все классы-потомки. В
последующем, возможно, восполнить их перечень, не изменяя уже построенную диаграмму.
3. {disjoint} означает тот факт, что классы-потомки не могут содержать объектов, одновременно являющихся
экземплярами двух или более классов.
В приведенном выше примере это условие также выполняется, поскольку предполагается, что никакое
конкретное физическое лицо не может являться одновременно и конкретной компанией. В этом случае рядом с
линией обобщения можно записать данную строку-ограничение.
4. {overlapping} означает, что отдельные экземпляры классов-потомков могут принадлежать одновременно
нескольким классам.
Например, класс Транспорт может быть специализирован путем создания подклассов Наземный_Транспорт и
Водный_Транспорт, автомобиль – амфибия относится к обоим классам.













## Диаграмма деятельности (Activity)

Технология позволяет наглядно визуализировать происходящие бизнес-процессы и существующие потоки движения. Activity diagram – это диаграмма для демонстрации рабочего процесса некоторой деятельности, основанной на поэтапных действиях и действиях с поддержкой выбора и параллелизма.
Диаграмма деятельности — технология, позволяющая описывать логику процедур, бизнес-процессы и потоки работ. Основным отличием диаграмм деятельности от блок-схем является активная поддержка параллельных процессов, что объясняет применение диаграммы деятельности для моделирования потоков работ


**Дорожка** (англ. swimlane) — часть области диаграммы деятельности для отображения деятельностей, за которые отвечает конкретный объект (например, пользователь или организационное подразделение). Диаграмма-пример содержит две дорожки: «Система» и «Клиент». Диаграмма деятельности должна начинаться с **начального узла** (англ. activity initial node), в котором начинаются поток или потоки при вызове деятельности извне, и завершаться **конечным узлом** (англ. activity final node), который останавливает все потоки данной деятельности. В примере начальный узел изображается голубым кругом, а конечный узел — серым. 

**Операции** (англ. operations) являются ключевыми элементами диаграммы деятельности и отображаются зелеными овалами. 

**Решение** (англ. decision) имеет один входящий и несколько защищенных выходящих потоков. Защитой является условное выражение, помещенное в скобки. Так как при достижении решения выбирается только один из выходных потоков, защиты должны быть взаимоисключающими.

**Слияние** (англ. merge) означает завершение условного поведения, которое было начато решением.

Для реализации параллельных потоков используются точки разделения и точки слияния. Из **точки разделения** (англ. fork node) выходят два и более потока, выполняющихся паралелльно. **Точка слияния** (англ. join node) синхронизирует потоки, т. к. каждый из них ждет достижения этой точки остальными потоками, после чего продолжается последовательное исполнение.

![Activity](https://user-images.githubusercontent.com/26972859/166219419-2a05e1e2-aacd-4162-812e-89474145a676.png)

При моделировании поведения проектируемой или анализируемой системы возникает необходимость не
только представить процесс изменения ее состояний, но и детализировать особенности алгоритмической и логической реализации выполняемых системой операций. Традиционно для этой цели использовались блок-схемы или структурные схемы алгоритмов. Каждая такая схема акцентирует внимание на последовательности выполнения определенных действий или элементарных операций, которые в совокупности приводят к получению желаемого результата.
Алгоритмические и логические операции, требующие выполнения в определенной последовательности,
окружают нас постоянно. Например, чтобы позвонить по телефону, нам предварительно нужно снять трубку или включить его. Для приготовления кофе или заваривания чая необходимо вначале вскипятить воду. Чтобы выполнить ремонт двигателя автомобиля, требуется осуществить целый ряд нетривиальных операций, таких как разборка силового агрегата, снятие генератора и некоторых других.
C увеличением сложности системы строгое соблюдение последовательности выполняемых операций
приобретает все более важное значение. Если попытаться заварить кофе холодной водой, то мы можем только испортить одну порцию напитка. Нарушение последовательности операций при ремонте двигателя может привести к его поломке или выходу из строя. Еще более катастрофические последствия могут произойти в случае отклонения от установленной последовательности действий при взлете или посадке авиалайнера, запуске ракеты, регламентных работах на АЭС.
Для моделирования процесса выполнения операций в языке UML используются так называемые диаграммы
деятельности. Применяемая в них графическая нотация во многом похожа на нотацию диаграммы состояний, поскольку на диаграммах деятельности также присутствуют обозначения состояний и переходов. Отличие заключается в семантике состояний, которые используются для представления не деятельностей, а действий, и в отсутствии на переходах сигнатуры событий. Каждое состояние на диаграмме деятельности соответствует выполнению некоторой элементарной операции, а переход в следующее состояние срабатывает только при завершении этой операции в предыдущем состоянии. 
Графически диаграмма деятельности представляется в форме графа деятельности, вершинами которого являются состояния действия, а дугами – переходы от одного состояния  действия к другому.
Таким образом, диаграммы деятельности можно считать частным случаем диаграмм состояний. Основным
направлением использования диаграмм деятельности является визуализация особенностей реализации операций классов, когда необходимо представить алгоритмы их выполнения. При этом каждое состояние может являться выполнением операции некоторого класса либо ее части, позволяя использовать диаграммы деятельности для описания реакций на внутренние события системы.
В контексте языка UML деятельность (activity) представляет собой некоторую совокупность отдельных
вычислений, выполняемых автоматом. При этом отдельные элементарные вычисления могут приводить к
некоторому результату или действию (action). На диаграмме деятельности отображается логика или
последовательность перехода от одной деятельности к другой, при этом внимание фиксируется на результате деятельности. Сам же результат может привести к изменению состояния системы или возвращению некоторого значения.

Состояние действия и деятельности
Состояние деятельности (activity state) – состояние в графе деятельности, которое служит для
представления процедурной последовательности действий, требующих определенного времени. Переход из
состояния деятельности происходит после выполнения специфицированной в нем ду-деятельности, при этом
ключевое слово do в имени деятельности не указывается. Состояние деятельности не может иметь внутренних
переходов, поскольку оно является элементарным.

Состояния деятельности могут быть подвергнуты дальнейшей декомпозиции, вследствие чего выполняемую
деятельность можно представить с помощью других диаграмм деятельности. Состояния деятельности не являются
атомарными, то есть могут быть прерваны. Предполагается, что для их завершения требуется заметное время.
Состояние деятельности можно представлять себе, как составное состояние, поток управления которого
включает только другие состояния деятельности и действий.
Состояние действия (action state) является специальным случаем состояния с некоторым входным действием
и, по крайней мере, одним выходящим из состояния переходом. Этот переход неявно предполагает, что входное
действие уже завершилось. Состояние действия не может иметь внутренних переходов, поскольку оно является
элементарным. Обычное использование состояния действия заключается в моделировании одного шага
выполнения алгоритма (процедуры) или потока управления.
Графически состояние действия изображается фигурой, напоминающей прямоугольник, боковые стороны
которого заменены выпуклыми дугами (рис. 1). Внутри этой фигуры записывается выражение действия (actionexpression), которое должно быть уникальным в пределах одной диаграммы деятельности.

Действие может быть записано на естественном языке, некотором псевдокоде или языке программирования.
Никаких дополнительных или неявных ограничений при записи действий не накладывается. Рекомендуется в
качестве имени простого действия использовать глагол с пояснительными словами (рис. 1а). Если же действие
может быть представлено в некотором формальном виде, то целесообразно записать его на том языке
программирования, на котором предполагается реализовывать конкретный проект (рис. 1б).
Иногда возникает необходимость представить на диаграмме деятельности некоторое сложное действие,
которое, в свою очередь, состоит из нескольких более простых действий. В этом случае можно использовать
специальное обозначение так называемого состояния поддеятельности (subactivity state). Такое состояние
является графом деятельности и обозначается специальной пиктограммой в правом нижнем углу символа
состояния действия (рис. 2). Эта конструкция может применяться к любому элементу языка UML, который
поддерживает «вложенность» своей структуры. При этом пиктограмма может быть дополнительно помечена
типом вложенной структуры.

Каждая диаграмма деятельности должна иметь единственное начальное и единственное конечное состояния.
Они имеют такие же обозначения, как и на диаграмме состояний (см. практическое занятия №9). При этом каждая
деятельность начинается в начальном состоянии и заканчивается в конечном состоянии. Саму диаграмму
деятельности принято располагать таким образом, чтобы действия следовали сверху вниз. В этом случае начальное
состояние будет изображаться в верхней части диаграммы, а конечное – в ее нижней части.

Переходы
При построении диаграммы деятельности используются только такие переходы, которые срабатывают сразу
после завершения деятельности или выполнения соответствующего действия. Этот переход переводит
деятельность в последующее состояние сразу, как только закончится действие в предыдущем состоянии. На
диаграмме такой переход изображается сплошной линией со стрелкой.
Если из состояния действия выходит единственный переход, то он может быть никак не помечен. Если же
таких переходов несколько, то сработать может только один из них. Именно в этом случае для каждого из таких
переходов должно быть явно записано сторожевое условие в прямых скобках. При этом для всех выходящих из
некоторого состояния переходов должно выполняться требование истинности только одного из них. Подобный
случай встречается тогда, когда последовательно выполняемая деятельность должна разделиться на
альтернативные ветви в зависимости от значения некоторого промежуточного результата. Такая ситуация
получила название ветвления, а для ее обозначения применяется специальный символ.

Графически ветвление на диаграмме деятельности обозначается небольшим ромбом, внутри которого нет
никакого текста (рис. 3). В этот ромб может входить только одна стрелка от того состояния действия, после
выполнения которого поток управления должен быть продолжен по одной из взаимно исключающих ветвей.
Принято входящую стрелку присоединять к верхней или левой вершине символа ветвления. Выходящих стрелок
может быть две или более, но для каждой из них явно указывается соответствующее сторожевое условие в форме
булевского выражения.
В качестве примера рассмотрим фрагмент известного алгоритма нахождения корней квадратного уравнения.
В общем случае после приведения уравнения второй степени к каноническому виду: 𝑎 ∗ 𝑥 ∗ 𝑥 + 𝑏 ∗ 𝑥 + 𝑐 = 0
необходимо вычислить его дискриминант. Причем, в случае отрицательного дискриминанта уравнение не имеет
решения на множестве действительных чисел, и дальнейшие вычисления должны быть прекращены. При
неотрицательном дискриминанте уравнение имеет решение, корни которого могут быть получены на основе
конкретной расчетной формулы.
Графически фрагмент процедуры вычисления корней квадратного уравнения может быть представлен в виде
диаграммы деятельности с тремя состояниями действия и ветвлением (рис. 3). Каждый из переходов, выходящих
из состояния «Вычислить дискриминант», имеет сторожевое условие, определяющее единственную ветвь, по
которой может быть продолжен процесс вычисления корней в зависимости от знака дискриминанта. Очевидно, что
в случае его отрицательности, мы сразу попадаем в конечное состояние, тем самым завершая выполнение
алгоритма в целом.

Рисунок 151 – Фрагмент диаграммы деятельности для алгоритма нахождения корней квадратного уравнения
В рассмотренном примере, как видно из рис. 3, выполняемые действия соединяются в конечном состоянии.
Однако это вовсе не является обязательным. Можно изобразить еще один символ ветвления, который будет иметь
несколько входящих переходов и один выходящий.
Один из наиболее значимых недостатков обычных блок-схем или структурных схем алгоритмов связан с
проблемой изображения параллельных ветвей отдельных вычислений. Поскольку распараллеливание вычислений
существенно повышает общее быстродействие программных систем, необходимы графические примитивы для
представления параллельных процессов. В языке UML для этой цели используется специальный символ для
разделения и слияния параллельных вычислений или потоков управления. Таким символом является прямая
черточка.
Такая черточка изображается отрезком горизонтальной линии, толщина которой несколько шире основных
сплошных линий диаграммы деятельности. При этом разделение (concurrent fork) имеет один входящий переход и
несколько выходящих (рис. 4а). Слияние (concurrent join), наоборот, имеет несколько входящих переходов и один
выходящий (рис. 4б).

Рисунок 152 – Графическое обозначение разделения и слияния параллельных потоков управления
Для иллюстрации особенностей параллельных процессов выполнения действий рассмотрим пример с
приготовлением напитка. Достоинство этого примера состоит в том, что он практически не требует никаких
дополнительных пояснений в силу своей очевидности (рис. 5).

Хотя диаграмма деятельности предназначена для моделирования поведения систем, время в явном виде
отсутствует на этой диаграмме. Ситуация здесь во многом аналогична диаграмме состояний.
Таким образом, диаграмма деятельности есть не что иное, как специальный случай диаграммы состояний, в
которой все или большинство состояний являются действиями или состояниями поддеятельности. А все или
большинство переходов являются переходами, которые срабатывают по завершении действий или поддеятельностей в состояниях источниках.

Дорожки
Диаграммы деятельности могут быть использованы не только для спецификации алгоритмов вычислений или
потоков управления в программных системах. Не менее важная область их применения связана с моделированием
бизнес-процессов. Действительно, деятельность любой компании (фирмы) также представляет собой не что иное,
как совокупность отдельных действий, направленных на достижение требуемого результата. Однако
применительно к бизнес-процессам желательно выполнение каждого действия ассоциировать с конкретным
подразделением компании. В этом случае подразделение несет ответственность за реализацию отдельных
действий, а сам бизнес-процесс представляется в виде переходов действий из одного подразделения к другому.
Для моделирования этих особенностей в языке UML используется специальная конструкция, получившее
название дорожки (swimlanes). Имеется в виду визуальная аналогия с плавательными дорожками в бассейне, если
смотреть на соответствующую диаграмму. При этом все состояния действия на диаграмме деятельности делятся 
на отдельные группы, которые отделяются друг от друга вертикальными линиями. Две соседние линии и образуют
дорожку, а группа состояний между этими линиями выполняется отдельным подразделением (отделом, группой,
отделением, филиалом) компании (рис. 6).

Рисунок 154 – Вариант диаграммы деятельности с дорожками
Названия подразделений явно указываются в верхней части дорожки. Пересекать линию дорожки могут
только переходы, которые в этом случае обозначают выход или вход потока управления в соответствующее
подразделение компании. Порядок следования дорожек не несет какой-либо семантической информации и
определяется соображениями удобства.
В качестве примера рассмотрим фрагмент диаграммы деятельности торговой компании, обслуживающей
клиентов по телефону. Подразделениями компании являются отдел приема и оформления заказов, отдел продаж и
склад.
Этим подразделениям будут соответствовать три дорожки на диаграмме деятельности, каждая из которых
специфицирует зону ответственности подразделения. В данном случае диаграмма деятельности заключает в себе
не только информацию о последовательности выполнения рабочих действий, но и о том, какое из подразделений
торговой компании должно выполнять то или иное действие (рис. 7).
Из указанной диаграммы деятельности сразу видно, что после принятия заказа от клиента отделом приема и
оформления заказов осуществляется распараллеливание деятельности на два потока (переход-разделение). Первый
из них остается в этом же отделе и связан с получением оплаты от клиента за заказанный товар. Второй инициирует
выполнение действия по подбору товара в отделе продаж (модель товара, размеры, цвет, год выпуска и пр.). По
окончании этой работы инициируется действие по отпуску товара со склада. Однако подготовка товара к отправке
в торговом отделе начинается только после того, как будет получена оплата за товар от клиента и товар будет
отпущен со склада (переход-соединение). Только после этого товар отправляется клиенту, переходя в его
собственность.
Объекты
В общем случае действия на диаграмме деятельности выполняются над теми или иными объектами. Эти
объекты либо инициируют выполнение действий, либо определяют некоторый результат этих действий. При этом
действия специфицируют вызовы, которые передаются от одного объекта графа деятельности к другому.
Поскольку в таком ракурсе объекты играют определенную роль в понимании процесса деятельности, иногда
возникает необходимость явно указать их на диаграмме деятельности.
Для графического представления объектов используются прямоугольник класса, с тем отличием, что имя
объекта подчеркивается. Далее после имени может указываться характеристика состояния объекта в прямых
скобках. Такие прямоугольники объектов присоединяются к состояниям действия отношением зависимости
пунктирной линией со стрелкой. Соответствующая зависимость определяет состояние конкретного объекта после
выполнения предшествующего действия.
На диаграмме деятельности с дорожками расположение объекта может иметь некоторый дополнительный
смысл. А именно, если объект расположен на границе двух дорожек, то это может означать, что переход к
следующему состоянию действия в соседней дорожке ассоциирован с готовностью некоторого документа (объект
в некотором состоянии). Если же объект целиком расположен внутри дорожки, то и состояние этого объекта
целиком определяется действиями данной дорожки.
Возвращаясь к предыдущему примеру с торговой компанией, можно заметить, что центральным объектом
процесса продажи является заказ или вернее состояние его выполнения. Вначале до звонка от клиента заказ как
объект отсутствует и возникает лишь после такого звонка. Однако этот заказ еще не заполнен до конца, поскольку
требуется еще подобрать конкретный товар в отделе продаж. После его подготовки он передается на склад, где
вместе с отпуском товара заказ окончательно дооформляется. Наконец, после получения подтверждения об оплате
товара эта информация заносится в заказ, и он считается выполненным и закрытым. Данная информация может
быть представлена графически в виде модифицированного варианта диаграммы деятельности этой же торговой
компании (рис. 8).






## Проектирование диаграммы последовательности (Sequence)

Пришло время поговорить о диаграмме последовательности UML, которые позволяют наглядно увидеть взаимодействие отдельных объектов. Давайте спроектируем собственную диаграмму и разберем ее основные элементы.

Диаграмма последовательности UML
-Диаграмма последовательности позволяет изобразить поведение нескольких объектов в рамках одного прецедента
-Диаграмма последовательности удобна для представления взаимодействия объектов, но не для точного определения их поведения
-Диаграмма показывает экземпляры объектов и сообщения, которыми обмениваются экземпляры в рамках одного прецедента

В данном занятии демонстрируется построение диаграммы последовательности ответа фитнес-тренера на заявку клиента. Основные шаги построения диаграммы последовательности:
-добавление основных элементов
-работа с сообщениями

Объекты обычно подписываются в формате «объект:класс» и изображаются как в виде обычных прямоугольников, так и с использованием дополнительных обозначений. В представленном примере объектами являются запрос, обозначенный прямоугольником, а также тренер и клиент, обозначенные элементом «Актер». 

Линия жизни (англ. lifeline) идет вертикально вниз от каждого объекта и упорядочивает сообщения на странице таким образом, чтобы они читались сверху вниз. Каждая линия жизни имеет полосу активности (зеленые вертикальные прямоугольники), показывающую интервал активности участника при взаимодействии.

Сообщения показывают взаимодействие между объектами в виде горизонтальной стрелки, концы которой лежат на линиях жизни. Направление стрелки указывает на адресата, а положение на линии жизни упорядочивает сообщения по времени. При создании нового объекта и применении конструктора можно не указывать имя сообщения, указав ключевое слово «new».

Условия, как и циклы, изображаются с помощью фреймов взаимодействий (англ. interaction frames), позволяющих разметить диаграмму взаимодействия. Каждый фрейм представляет собой разделенную на несколько фрагментов область диаграммы, причем каждый фрейм имеет оператор, а каждый фрагмент может иметь защиту. В данном примере для условной логики используется оператор alt и будет выполнено условие, защита которого имеет истинное значение.

Для отображения цикла применяется оператор loop с единственным фрагментом, причем тело итерации помещается в защиту. В данном случае для добавления тренером упражнений в план занятий используется метод «AddExercise». Данный метод создает объект «newPersonalTraining», который далее возвращается тренеру.

![Sequence](https://user-images.githubusercontent.com/26972859/166225415-6ca92924-a961-4994-ac73-88eef7eddbdd.png)


Диаграммы последовательностей описывают взаимодействия множества объектов, включая сообщения,
которыми они обмениваются.
В отличие от диаграммы классов, на которой изображаются абстрактные элементы в виде классов, на
диаграмме последовательностей используются конкретные экземпляры классов – объекты. Объекты
отображаются прямоугольником без полей. Для того чтобы подчеркнуть, что это экземпляр абстрактной сущности,
название объекта подчеркивается. При необходимости через двоеточие после названия можно указать сущность
(класс) экземпляром которой является этот объект. Отметим, что объект может быть экземпляром не только класса,
но и других абстракций, например, актера. Обратите внимание, что при указании в качестве классификатора актера
изменится графическое обозначение объекта (рис. 1).

На диаграмме последовательностей у объекта может присутствовать линия жизни, на которой отмечаются
происходящие с объектом события. Линия жизни отображается пунктирной линией (рис. 2).
Между собой объекты могут быть связаны связями. Связь – это экземпляр отношения ассоциация, и имеет
такое же графическое обозначение, что и ассоциация.
На диаграмме последовательностей объекты обмениваются сообщениями. Сообщение – это спецификация
передачи данных от одного объекта другому, который предполагает какое-то ответное действие. Графически
сообщение обозначается сплошной линией со стрелкой.
Часто операция вызывает какую-либо операцию в объекте. Очевидно, что класс, экземпляром которого
является объект, должен иметь такую операцию. Привязка сообщения к операции класса объекта выполняется в
свойствах сообщения (рис. 2).

При построении диаграммы классов обычно определяются только основные свойства сущностей, а такие
детали, как операции, удобно создавать при построении диаграммы последовательности, для чего в свойствах
сообщения UML есть кнопка создания операции.
Диаграммы последовательностей, как и другие диаграммы для отображения динамических свойств системы,
могут быть выполнены в контексте многих сущностей UML. Они могут описывать поведение системы в целом,
подсистемы, класса или операции класса и др. К сожалению, Visio недостаточно гибка в плане поддержки
раскрытия содержания отдельных элементов с помощью других диаграмм. Например, кликнув правой кнопкой
мыши по классу можно обнаружить, что для его описания можно создать лишь диаграммы классов, состояний и
деятельности. Поэтому возможность привязать диаграмму последовательностей к элементу, который она
реализует, средствами Visio невозможно, эту связь нужно подразумевать.
Диаграммы последовательностей будем делать в контексте прецедентов с диаграммы прецедентов, реализуя
те функции, которые должна выполнять наша система.
При построении динамических диаграмм используется уже разработанная структура информационной
системы. Для диаграммы последовательностей не нужно придумывать объекты, а достаточно определить,
экземпляры каких классов участвуют в этом действии.
Определив необходимые объекты (как экземпляры классов, так и экземпляры актеров), вторым этапом
построения диаграмм последовательностей определяются сообщения, пересылаемые между актерами. Фактически
определяется последовательность шагов, для выполнения нужного действия.



## Проектирование диаграммы состояний (StateChart)

	Диаграмма состояний позволяет наглядно описать поведение объекта. Давайте разберем этапы проектирования такой диаграммы и познакомимся с основными элементами.
Диаграмма состояний позволяет описывать поведение системы. В объектно-ориентированном подходе разрабатывается диаграмма состояний единственного класса, демонстрирующая поведение одного объекта в течение его жизни. Состояние на диаграмме является более абстрактным понятием, чем состояние объекта (последнее есть комбинация всех данных из полей объекта). Диаграмма позволяет проектировать различные способы реакции на события. Основные шаги построения диаграммы состояний:
-добавление состояний
-указание переходов
-добавление внутренних активностей
-указание подсостояний и суперсостояний

	Для построения диаграммы последовательности используется шаблон UML State Machine из раздела Software and Database программы Visio.
Начальное псевдосостояние (initial pseudostate) не является состоянием, но имеет стрелку, указывающую на начальное состояние. На диаграмме отображаются состояния, в которых объект может находиться продолжительное время. Состояние может быть прервано вследствие наступления определенного события. Пример состояния заявки: «autorization»

	Переход (transition) означает перемещение из одного состояния в другое и изображается в виде линий, связывающих состояния. Каждый переход имеет метку, состоящую из следующих необязательных частей:
Триггер-идентификатор — единственное событие, способное вызвать изменение состояния. Пропуск этой части означает, что переход происходит немедленно.
Защита — логическое условие, выполнение которого обязательно для осуществления перехода. Пропуск защиты означает, что в ответ на инициирующее событие переход всегда осуществляется.
Активность — поведение системы во время перехода. Пропуск активности означает, что в процессе перехода ничего не происходит.

	На представленной диаграмме методы «Авторизован()» и «Неавторизован()» служат примерами событий, вызывающих переходы между состояниями. Примером защиты является выражение «[Autorization == true]».

	Добавление внутренних активностей. Внутренние активности (internal activities) используются для описания действий объекта, совершаемых без перехода. Список основных действий включает следующие значения:
- входное действие (entry) — действие, которое выполняется в момент входа в данное состояние;
- выходное действие (exit) — действие, которое выполняется в момент выхода из данного состояния;
- выполняющая деятельность (do) — действие, которое выполняется в течение всего времени нахождения объекта в данном состоянии. Разница между обычными и выполняющими деятельностями / активностями состоит в том, что первые происходят мгновенно и не могут быть прерваны обычными событиями;

	Работа с общими переходами и внутренними активностями. В случае наличия у нескольких состояний общих переходов и внутренних активностей, само состояние можно превратить в подсостояние (substates), а их общее поведение перенести в суперсостояние (superstate).

![StateChart](https://user-images.githubusercontent.com/26972859/166230843-9a5ffd02-a8d0-4d4f-9fcf-ca22341a60e8.png)


Диаграмма состояний описывает процесс изменения состояний только одного класса, а точнее – одного
экземпляра определенного класса, т. е. моделирует все возможные изменения в состоянии конкретного объекта.
При этом изменение состояния объекта может быть вызвано внешними воздействиями со стороны других объектов
или извне. Именно для описания реакции объекта на подобные внешние воздействия и используются диаграммы
состояний.
Диаграмма состояний описывает возможные последовательности состояний и переходов, которые в
совокупности характеризуют поведение элемента модели в течение его жизненного цикла. Диаграмма состояний
представляет динамическое поведение сущностей, на основе спецификации их реакции на восприятие некоторых
конкретных событий.
Хотя диаграммы состояний чаще всего используются для описания поведения отдельных экземпляров классов
(объектов), но они также могут быть применены для спецификации функциональности других компонентов
моделей, таких как варианты использования, актеры, подсистемы, операции и методы.
Диаграмма состояний по существу является графом специального вида, который представляет некоторый
автомат. Понятие автомата в контексте UML обладает довольно специфической семантикой, основанной на теории
автоматов. Вершинами этого графа являются состояния и некоторые другие типы элементов автомата
(псевдосостояния), которые изображаются соответствующими графическими символами. Дуги графа служат для
обозначения переходов из состояния в состояние. Диаграммы состояний могут быть вложены друг в друга, образуя
вложенные диаграммы более детального представления отдельных элементов модели.

Состояние
Под состоянием понимается абстрактный метакласс, используемый для моделирования отдельной ситуации,
в течение которой имеет место выполнение некоторого условия. Состояние может быть задано в виде набора
конкретных значений атрибутов класса или объекта, при этом изменение их отдельных значений будет отражать
изменение состояния моделируемого класса или объекта.

Секция «Список внутренних действий» содержит перечень внутренних действий или деятельностей, которые
выполняются в процессе нахождения моделируемого элемента в данном состоянии. Каждое из действий
записывается в виде отдельной строки и имеет следующий формат:
<метка-действия '/' выражение-действия>

Метка действия указывает на обстоятельства или условия, при которых будет выполняться деятельность,
определенная выражением действия:
‒ entry – эта метка указывает на действие, специфицированное следующим за ней выражением действия,
которое выполняется в момент входа в данное состояние (входное действие);
‒ exit – эта метка указывает на действие, специфицированное следующим за ней выражением действия,
которое выполняется в момент выхода из данного состояния (выходное действие);
‒ do – эта метка специфицирует выполняющуюся деятельность («doactivity»), которая выполняется в течение
всего времени, пока объект находится в данном состоянии, или до тех пор, пока не закончится вычисление,
специфицированное следующим за ней выражением действия. В последнем случае при завершении события
генерируется соответствующий результат;
‒ include – эта метка используется для обращения к подавтомату, при этом следующее за ней выражение
действия содержит имя этого подавтомата.


Начальное и конечное состояния
Начальное состояние представляет собой частный случай состояния, которое не содержит никаких
внутренних действий (псевдосостояния). В этом состоянии находится объект по умолчанию в начальный момент
времени. Оно служит для указания на диаграмме состояний графической области, от которой начинается процесс
изменения состояний.
Конечное (финальное) состояние представляет собой частный случай состояния, которое также не содержит
никаких внутренних действий (псевдосостояния). В этом состоянии будет находиться объект по умолчанию после
завершения работы автомата в конечный момент времени.

Переход
Простой переход (simpletransition) представляет собой отношение между двумя последовательными
состояниями, которое указывает на факт смены одного состояния другим. Пребывание моделируемого объекта в
первом состоянии может сопровождаться выполнением некоторых действий, а переход во второе состояние будет
возможен после завершения этих действий, а также после удовлетворения некоторых дополнительных условий. В
этом случае говорят, что переход срабатывает, Или происходит срабатывание перехода. До срабатывания перехода
объект находится в предыдущем от него состоянии, называемым исходным состоянием, или в источнике (не путать
с начальным состоянием – это разные понятия), а после его срабатывания объект находится в последующем от
него состоянии (целевом состоянии).
Переход осуществляется при наступлении некоторого события: окончания выполнения деятельности
(doactivity), получении объектом сообщения или приемом сигнала. На переходе указывается имя события. Кроме
того, на переходе могут указываться действия, производимые объектом в ответ на внешние события при переходе
из одного состояния в другое. Срабатывание перехода может зависеть не только от наступления некоторого
события, но и от выполнения определенного условия, называемого сторожевым условием. Объект перейдет из
одного состояния в другое в том случае, если произошло указанное событие и сторожевое условие приняло
значение «истина».
На диаграмме состояний переход изображается сплошной линией со стрелкой, которая направлена в целевое
состояние. Каждый переход может помечен строкой текста, которая имеет следующий общий формат:
<сигнатура события>'['<сторожевое условие>']' <выражение действия>

Событие представляет собой спецификацию некоторого факта, имеющего место в пространстве и во времени.
Про события говорят, что они «происходят», при этом отдельные события должны быть упорядочены во времени.
После наступления некоторого события нельзя уже вернуться к предыдущим событиям, если такая возможность
не предусмотрена явно в модели.
События играют роль стимулов, которые инициируют переходы из одних состояний в другие. В качестве
событий можно рассматривать сигналы, вызовы, окончание фиксированных промежутков времени или моменты
окончания выполнения определенных действий. Имя события идентифицирует каждый отдельный переход на
диаграмме состояний и может содержать строку текста, начинающуюся со строчной буквы.

Сторожевое условие
Сторожевое условие (guardcondition), если оно есть, всегда записывается в прямых скобках после события и
представляет собой некоторое булевское выражение.
Если сторожевое условие принимает значение «истина», то соответствующий переход может сработать, в
результате чего объект перейдет в целевое состояние. Если же сторожевое условие принимает значение «ложь», то
переход не может сработать, и при отсутствии других переходов объект не может перейти в целевое состояние по
этому переходу. Однако вычисление истинности сторожевого условия происходит только после возникновения
ассоциированного с ним события, инициирующего соответствующий переход.
В общем случае из одного состояния может быть несколько переходов с одним и тем же событием-триггером.
При этом никакие два сторожевых условия не должны одновременно принимать значение «истина». Каждое из
сторожевых условий необходимо вычислять всякий раз при наступлении соответствующего события.

Составное состояние и подсостояние
Составное состояние (compositestate) – такое сложное состояние, которое состоит из других вложенных в
него состояний. Последние будут выступать по отношению к первому как подсостояния (substate).

Последовательные подсостояния (sequential substates) используются для моделирования такого поведения
объекта, во время которого в каждый момент времени объект может находиться в одном и только одном
подсостояний. Поведение объекта в этом случае представляет собой последовательную смену подсостояний,
начиная от начального и заканчивая конечным подсостояниями. Хотя объект продолжает находиться в составном
состоянии, введение в рассмотрение последовательных подсостояний позволяет учесть более тонкие логические
аспекты его внутреннего поведения.

Параллельные подсостояния (concurrentsubstates) позволяют специфицировать два и более подавтомата,
которые могут выполняться параллельно внутри составного события. Каждый из подавтоматов занимает
некоторую область (регион) внутри составного состояния, которая отделяется от остальных горизонтальной
пунктирной линией. Если на диаграмме состояний имеется составное состояние с вложенными параллельными
подсостояниями, то объект может одновременно находиться в каждом из этих подсостояний.

Синхронизирующие состояния
Поведение параллельных подавтоматов независимо друг от друга, что позволяет реализовать многозадачность
в программных системах. Однако в отдельных случаях может возникнуть необходимость учесть в модели
синхронизацию наступления отдельных событий. Для этой цели в языке UML имеется специальное
псевдосостояние, которое называется синхронизирующим состоянием.
Синхронизирующее состояние (synch state) обозначается небольшой окружностью, внутри которой помещен
символ звездочки "*". Оно используется совместно с переходом-соединением или переходом-ветвлением для того,
чтобы явно указать события в других подавтоматах, оказывающие непосредственное влияние на поведение
данного подавтомата.
Для иллюстрации использования синхронизирующих состояний рассмотрим упрощенную ситуацию с
моделированием процесса постройки дома. Предположим, что постройка дома включает в себя строительные
работы (возведение фундамента и стен, возведение крыши и отделочные работы) и работы по электрификации
дома (подведение электрической линии, прокладка скрытой электропроводки и установка осветительных ламп).
Очевидно, два этих комплекса работ могут выполняться параллельно, однако между ними есть некоторая
взаимосвязь.
В частности, прокладка скрытой электропроводки может начаться лишь после того, как будет завершено
возведение фундамента и стен. А отделочные работы следует начать лишь после того, как будет закончена
прокладка скрытой электропроводки. В противном случае отделочные работы придется проводить повторно.
Рассмотренные особенности синхронизации этих параллельных процессов учтены на соответствующей диаграмме
состояний с помощью двух синхронизирующих состояний.





















## Построение модели IDEFIX

Методология IDEF1X – язык для семантического моделирования данных, основанный на концепции
«сущность-связь».

Различают два уровня информационной модели: логический и физический.
Логическая модель позволяет понять суть проектируемой системы, отражая логические взаимосвязи между
сущностями.

Различают 3 подуровня логического уровня модели данных, отличающиеся по глубине представления
информации о данных:
 диаграмма сущность-связь (Entity-Relationship Diagram (ERD);
 модель данных, основанная на ключах (Key Based Model (KB);
 полная атрибутивная модель (Fully Attributed Model (FA).
Физическая модель отражает физические свойства проектируемой базы данных (типы данных, размер
полей, индексы). Параметры физической информационной модели зависят от выбранной системы управления
базами данных (СУБД).

Сущность – это множество реальных или абстрактных объектов (людей, предметов, документов и т.п.),
обладающих общими атрибутами или характеристиками. Любой объект системы может быть представлен
только одной сущностью, которая должна быть уникально идентифицирована. Именование сущности
осуществляется с помощью существительного в единственном числе. При этом имя сущности должно отражать
тип или класс объекта, а не его конкретный экземпляр (например, Студент, а не Петров) (рис. 1).

Любая сущность характеризуется набором атрибутов (свойств).
Атрибут сущности – характеристика сущности, то есть свойство реального объекта. Например, на рис. 1
атрибутами сущности «Студент» являются «ID студента», «Фамилия», «Имя», «Отчество», «Дата
поступления» и «Номер билета».
В свою очередь, атрибуты сущности делятся на 2 вида: собственные и наследуемые. Собственные
атрибуты являются уникальными в рамках модели. Наследуемые атрибуты передаются от сущности-родителя при
установке связи с другими сущностями.

Первичный ключ (Primary Key, PK). Каждая сущность должна обладать атрибутом или комбинацией
атрибутов, чьи значения однозначно определяют каждый экземпляр сущности. Эти атрибуты образуют
первичный ключ сущности.

Внешний ключ (Foreign Key, FK). Если между двумя сущностями имеется специфическое отношение связи
или категоризации, то атрибуты, входящие в первичный ключ родительской или общей сущности, наследуются
в качестве атрибутов сущностью-потомком или категориальной сущностью соответственно. Эти атрибуты и называются внешними ключами. Наследуемый атрибут может использоваться в сущности в качестве части или
целого первичного ключа, альтернативного ключа или не ключевого атрибута.

Отношения в IDEF1X-модели
При построении информационной модели различают следующие типы отношений между сущностями:
идентифицирующее, не идентифицирующее, не специфическое (многие-ко-многим) и отношения категоризации.
Мощность отношения служит для обозначения отношения числа экземпляров родительской сущности к
числу экземпляров дочерней.

Нормализация данных
Нормализация – это процесс проверки и реорганизации сущностей и атрибутов с целью удовлетворения
требований к реляционной модели данных. Процесс нормализации сводится к последовательному приведению
структур данных к нормальным формам – формализованным требованиям к организации данных.
Первая нормальная форма (1НФ). Сущность находится в первой нормальной форме тогда и только тогда, когда
все атрибуты содержат атомарные значения. Среди атрибутов не должно встречаться повторяющихся групп, т.е.
несколько значений для каждого экземпляра.
Вторая нормальная форма (2НФ). Сущность находится во второй нормальной форме, если она находится в
первой нормальной форме, и каждый не ключевой атрибут полностью зависит от первичного ключа (не может
быть зависимости от части ключа).
Третья нормальная форма (3 НФ). Сущность находится в третьей нормальной форме, если она находится во
второй нормальной форме и никакой не ключевой атрибут не зависит от другого не ключевого атрибута (не должно
быть зависимости между не ключевыми атрибутами).

![IDEF1X](https://user-images.githubusercontent.com/26972859/166674859-daa2eb36-d5cb-46f9-9a81-2da645814092.png)


## Общие положения структурного метода

Сущность структурного подхода к разработке ИС заключается в декомпозиции (разбиении) системы на
автоматизируемые функции, которые в свою очередь делятся на подфункции, на задачи и так далее. Процесс декомпозиции продолжается вплоть до определения конкретных процедур. При этом автоматизируемая система сохраняет целостное представление, в котором все составляющие компоненты взаимосвязаны.

В основе структурного метода лежит несколько общих принципов:
‒ разбиение системы на множество независимых задач, доступных для понимания и решения;
‒ иерархическое упорядочивание, т.е. организация составных частей проблемы в древовидные структуры с добавлением новых деталей на каждом уровне.

К основным принципам относятся:
‒ абстрагирование, т.е. выделение существенных аспектов системы и отвлечение от несущественных;
‒ формализация, т.е. общее методологическое решение проблемы;
‒ непротиворечивость, состоящая в обосновании и согласовании элементов системы;
‒ иерархическая структуризация данных.

## Метод функционального моделирования SADT

На основе метода SADT, предложенного Д. Россом, разработана методология IDEF0 (Icam DEFinition),
которая является основной частью программы ICAM (Интеграция компьютерных и промышленных технологий), проводимой по инициативе ВВС США. Методология IDEF0 является наиболее признанным эффективным средством анализа, конструирования и отображения бизнес-процессов, применяемым также и широко за пределами США.

Метод SADT применяется при моделировании широкого круга систем, для которых определяются требования и функции, после чего проводится их реализация.

Методология SADT представляет собой совокупность методов, правил и процедур, предназначенных для
построения функциональной модели предметной области, которая отображает функциональную структуру,
производимые функции и действия, а также связи между ними.

Результат применения метода SADT – модель, которая состоит из диаграмм, фрагментов текстов и глоссария со ссылками друг на друга. Все функции и интерфейсы представляются диаграммами в виде, соответственно, блоков и дуг. Место соединения дуги с блоком определяет тип интерфейса. 

Управляющая информация входит в блок сверху, в то время как информация, которая подвергается обработке (исходные данные), указывается с левой стороны блока, а результаты работы функции (выход, результат) – с правой стороны. Механизм, осуществляющий операцию (человек или автоматизированная система), задается дугой, входящей в блок снизу.

Описание системы с помощью SADT называется моделью. Субъектом моделирования служит сама система.
Однако моделируемая система никогда не существует изолированно: она всегда связана с окружающей средой. По этой причине в методологии SADT подчеркивается необходимость точного определения границ системы, т.е. модель устанавливает точно, что является и что не является субъектом моделирования, описывая то, что входит в систему, и, подразумевая то, что лежит за ее пределами. SADT-модель должна иметь единственный субъект.
С определением модели тесно связана позиция (называемая точкой зрения), с которой наблюдается система и создается ее модель. «Точку зрения» лучше всего представлять себе как место (роль, должность) человека или объекта в рассматриваемой системе, на которое надо «встать», чтобы увидеть систему в действии и необходимой полноте. У конкретной модели может быть только одна точка зрения.
Обычно вопросы для SADT-модели формулируются на самом раннем этапе проектирования, при этом
основная суть этих вопросов должна быть выражена в одной-двух фразах, которые становятся целью модели.
После того как определены субъект, цель и точка зрения модели, начинается первая интеграция процесса моделирования по методологии SADT. Субъект определяет, что включить в модель, а что исключить из нее. Точка зрения диктует автору модели выбор нужной информации о субъекте и форму ее представления. Цель становится критерием окончания моделирования. Конечным результатом этого процесса является набор тщательно взаимоувязанных описаний, начиная с описания самого верхнего уровня системы и заканчивая подробным описанием ее деталей или отдельных операций.


Каждое из таких тщательно взаимосогласованных описаний называется диаграммой и имеет определенный
уровень детализации. SADT-модель объединяет и организует диаграммы в иерархические структуры, в которых диаграммы наверху модели менее детализированы, чем диаграммы нижних уровней. Другими словами, модель SADT можно представить в виде древовидной структуры диаграмм, где верхняя диаграмма является наиболее общей, а самые нижние – максимально детализированы.

Каждый блок на диаграмме имеет свой номер. Блок любой диаграммы может быть детализирован диаграммой нижнего уровня, которая, в свою очередь, также может детализироваться с помощью необходимого числа диаграмм. Таким образом, формируется иерархия диаграмм. Для того чтобы указать положение любой диаграммы или блока в иерархии, им присваивают уникальные обозначения. Например, А41 (A сокр. от Activity) является диаграммой, которая детализирует блок 1 на диаграмме А4. Аналогично, А4 детализирует блок 4 на диаграмме А0, которая является самой верхней (родительской) диаграммой модели. Некоторые дуги имеют начало в одном из блоков диаграммы и завершение в другом, у других же начало может исходить от границ диаграммы – дуги управления, механизма, дуги входа и выхода, перенесенные с родительской (верхнего уровня) диаграммы. Таким образом, источник или получатель этих пограничных дуг может быть обнаружен только на родительской диаграмме.
Также следует сказать о так называемых «туннельных дугах». Туннельные дуги означают, что данные,
выраженные этими дугами не рассматриваются на следующем уровне детализации (как бы проходят «насквозь»).

Если «туннель» расположен в месте соединения дуги с блоком « », то данные этой дуги не обязательны на следующем уровне детализации. Если же «туннель» находится на противоположном конце дуги « » – это значит, что данные дуги не описываются на родительской диаграмме. Граничные дуги должны продолжаться (дублироваться) на родительской диаграмме, делая ее полной и непротиворечивой.

Для упрощения понимания приведенных диаграмм, следует расшифровать применяемую в IDEF систему
обозначений, позволяющую аналитику точно идентифицировать и проверять по дугам связи между диаграммами.

Эта схема кодирования дуг – «ICOM» – получила название по первым буквам английских эквивалентов слов вход (Input), управление (Control), выход (Output), механизм (Mechanism).

## Методология IDEF0

Модель в нотации IDEF0 представляет собой совокупность иерархически упорядоченных и взаимосвязанных диаграмм. Каждая диаграмма является единицей описания системы и располагается на отдельном листе.

Цель моделирования. Модель не может быть построена без четко сформулированной цели. Пример цели:
«Описать функциональность предприятия с целью написания спецификаций ИС».

Точка зрения. Точку зрения можно представить как взгляд человека, который видит систему в нужном для моделирования аспекте. Как правило, выбирается точка зрения человека, ответственного за моделируемую работу в целом. Цель и точка зрения документируются.

Основные элементы IDEF0-модели
В основе методологии IDEF0 лежат 4 основных понятия:
‒ функциональный блок;
‒ интерфейсная дуга (стрелка);
‒ декомпозиция;
‒ глоссарий.

1. Функциональный блок
Функциональные блоки обозначают поименованные процессы, функции или задачи, которые происходят в
течение определенного времени и имеют распознаваемые результаты. Графически функциональные блоки
изображаются в виде прямоугольников. Все блоки должны быть названы и определены. Имя функционального блока должно быть выражено сочетанием отглагольного существительного, обозначающего процесс, или глаголом. 

Определение функционального блока заносится в глоссарий или словарь работ (Activity Dictionary).
Все функциональные блоки модели нумеруются. Номер состоит из префикса и числа. Может использоваться префикс любой длины, но обычно используется префикс А. Контекстная (корневая) работа (функциональный блок) имеет номер А0.

2. Интерфейсная дуга (стрелка – Arrow)
Взаимодействие функциональных блоков с внешним миром и между собой описывается в виде интерфейсных дуг (стрелок). Стрелки представляют собой некую информацию и обозначаются существительными (например, «Заготовка», «Изделие») или именуемыми сочетаниями (например, «Готовое изделие»). Все стрелки должны быть
определены. Определения заносятся в словарь стрелок – глоссарий (Arrow Dictionary).

В IDEF0 различают 4 типа стрелок.
Каждая стрелка имеет свое расположение относительно функционального блока.
Вход (Input) – материал или информация, которые используются или преобразуются работой для получения
результата (выхода). Стрелка Input рисуется входящей в левую грань работы.
Управление (Control) – правила, стратегии, процедуры или стандарты, которыми руководствуется работа.
Каждая работа должна иметь хотя бы одну стрелку управления. Рисуется как входящая в верхнюю грань работы.
Выход (Output) – материал или информация, которые производятся работой. Каждая работа должна иметь хотя бы одну стрелку выхода. Работа без результата не имеет смысла и не должна моделироваться. Изображается
исходящей из правой грани работы.
Механизм (Mechanism) – ресурсы, которые выполняют работу, например, персонал предприятия, станки,
устройства и т.д. Рисуется как входящая в нижнюю грань работы.

3. Глоссарий
Набор определений, ключевых слов и т.д., которые характеризуют каждый объект модели.

4. Декомпозиция
Разбиение системы на крупные фрагменты – функции, функции – на подфункции и т.д. до конкретных
процедур.

Модель может содержать 4 типа диаграмм:
‒ контекстную (в каждой модели может быть только 1 контекстная диаграмма);
‒ декомпозиции;
‒ дерева узлов;
‒ только для экспозиции (FEO).

Контекстная диаграмма является вершиной древовидной структуры диаграмм и представляет собой общее
описание системы и ее взаимодействия с внешней средой.
После описания системы в целом проводится разбиение ее на крупные фрагменты. Этот процесс называется
функциональной декомпозицией, а диаграммы, которые описывают каждый фрагмент и взаимодействие
фрагментов – диаграммами декомпозиции. После декомпозиции контекстной диаграммы проводится
декомпозиция каждого большого фрагмента системы на более мелкие и т.д., до достижения нужного уровня
подробности описания.


Диаграмма дерева узлов показывает иерархическую зависимость работ, но не взаимосвязи между работами.

Диаграммы для экспозиции (FEO) строятся для иллюстрации отдельных фрагментов модели, для иллюстрации альтернативной точки зрения либо для специальных целей.

Все диаграммы имеют нумерацию. Контекстная диаграмма имеет номер А-0, декомпозиция контекстной
диаграммы – номер А), остальные диаграммы-декомпозиции – номера по соответствующему узлу (например, А1, А2, А21 и т.д.).

Контекстная диаграмма

![IDEF0 контекстная диаграмма](https://user-images.githubusercontent.com/26972859/166676452-90e1f818-7fc4-4869-8ece-ca735e76f20b.png)

Диаграмма декомпозиции А-0

![IDEF0 декомпозиция А0](https://user-images.githubusercontent.com/26972859/166676492-9da7e83b-9b58-459f-95ad-4a77e2bf3fb8.png)

Дерево узлов

![IDEF0 дерево узлов](https://user-images.githubusercontent.com/26972859/166676532-7c749be0-eaed-4c3b-bbf7-0b4816dfc438.png)


## Общие сведения о диаграммах потоков данных

Диаграммы потоков данных (DFD, Data Flow Diagrams) являются основным средством моделирования
функциональных требований проектируемой системы. С их помощью эти требования разбиваются на
функциональные компоненты и представляются в виде сети связанных потоками данных процессов. Главная цель таких диаграмм – продемонстрировать, как каждый процесс преобразует свои входные данные в выходные, а также выявить отношения между этими процессами.








## Модель потоков данных DFD

DFD – data flow diagrams – диаграммы потоков данных – методология графического структурного анализа, описывающая внешние по отношению к системе источники и адресаты данных, логические функции, потоки данных и хранилища данных, к которым осуществляется доступ.

Диаграмма потоков данных – один из основных инструментов структурного анализа и проектирования
информационных систем, существовавших до широкого распространения UML.

Для описания диаграмм DFD используются две нотации – Йордана (Yourdon) и Гейна-Сарсона (Gane-Sarson), отличающиеся синтаксисом.

Основные элементы информационной модели логического уровня

Согласно DFD источники информации (внешние сущности) порождают информационные потоки (потоки
данных), переносящие информацию к подсистемам или процессам. Те в свою очередь преобразуют информацию и порождают новые потоки, которые переносят информацию к другим процессам или подсистемам, накопителям данных или внешним сущностям – потребителям информации.

Поток данных определяет информацию (материальный объект), передаваемую через некоторое соединение
от источника к приемнику. Реальный поток данных может быть информацией, передаваемой по кабелю между двумя устройствами, пересылаемыми по почте письмами, магнитными лентами или дискетами, переносимыми с одного компьютера на другой и т. д.
Каждый поток данных имеет имя, отражающее его содержание. Направление стрелки показывает направление потока данных. Иногда информация может двигаться в одном направлении, обрабатываться и возвращаться назад в ее источник. Такая ситуация может моделироваться либо двумя различными потоками, либо одним – двунаправленным.

На диаграммах IDEF0 потоки данных соответствуют входам и выходам, но в отличие от IDEF0 стрелки
потоков на DFD могут отображаться входящими и выходящими из любой грани внешней сущности, процесса или накопителя данных.

Процесс (в IDEF0 – функция, работа) представляет собой преобразование входных потоков данных в
выходные в соответствии с определенным алгоритмом.

Каждый процесс должен иметь имя в виде предложения с глаголом в неопределенной форме (вычислить,
рассчитать, проверить, определить, создать, получить), за которым следуют существительные в винительном падеже, например:
‒ «Ввести сведения о клиентах»;
‒ «Рассчитать допускаемую скорость»;
‒ «Сформировать ведомость допускаемых скоростей».

Номер процесса служит для его идентификации и ставится с учетом декомпозиции. Вложенность процессов обозначается через точку. Преобразование информации может показываться как с точки зрения процессов, так и с точки зрения систем и подсистем. Если вместо имени процесса «Рассчитать допускаемую скорость» написать «Подсистема расчета допускаемых скоростей», тогда этот блок на диаграмме стоит рассматривать, как подсистему. Накопитель (хранилище) данных представляет собой абстрактное устройство для хранения информации, которую можно в любой момент поместить в накопитель и через некоторое время извлечь, причем способы помещения и извлечения могут быть любыми. Накопитель данных может быть реализован физически в виде ящика в картотеке, области в оперативной памяти, файла на магнитном носителе и т.д. Накопителю обязательно должно даваться уникальное имя и номер в пределах всей модели (всего набора диаграмм). Имя накопителя выбирается из соображения наибольшей информативности для разработчика.
Например, если в качестве накопителей выступают таблицы проектируемой базы данных, тогда в качестве именнакопителей рекомендуется использовать имена таблиц. Таким образом, накопитель данных может представлять собой всю базу данных целиком, совокупность таблиц или отдельную таблицу. Такое представление накопителей в дальнейшем облегчит построение информационной модели системы.

Внешняя сущность (терминатор) представляет собой материальный объект или физическое лицо,
выступающие как источник или приемник информации (например, заказчики, персонал, программа, склад, инструкция). Внешние сущности на DFD по смыслу соответствуют управлению и механизмам, отображаемым на контекстной диаграмме IDEF0.
Определение некоторого объекта, субъекта или системы в качестве внешней сущности указывает на то, что она находится за пределами границ проектируемой информационной системы. В связи с этим внешние сущности, как правило, отображаются только на контекстной диаграмме DFD. В процессе анализа и проектирования некоторые внешние сущности могут быть перенесены на диаграммы декомпозиции, если это необходимо, или, наоборот, часть процессов (подсистем) может быть представлена как внешняя сущность.

Data Flow Diagram

![DFD](https://user-images.githubusercontent.com/26972859/166687817-0484f1ee-5646-4b7c-85da-fe6c4165fe7e.png)


## Техническое задание

Для обеспечения потребностей по разработке программного обеспечения (ПО) ИС необходимо
взаимосвязанное совершенствование технических решений, технологий проектирования и программирования, инструментальных средств, а также обучения специалистов.
Стандарты для процессов, инструментальных средств и данных, которые отражают лучшую практику и
защищают от неблагоприятных последствий, играют определенную роль в обеспечении указанных потребностей, в частности, поддерживая доверие потребителя к продуктам, услугам и технологиям разработки ПО.

Использование стандартов при разработке ПО ИС позволит обеспечить:
 повышение надежности;
 повышение эффективности применения и снижение затрат в сфере сопровождения программных средств
(ПС);
 увеличение коэффициента повторного использования ПС общего назначения;
 повышение объективности оценок качества ПС;
 создание условий для конкуренции разработчиков на внутреннем рынке ПС;
 обеспечение конкурентоспособности отечественных ПС на мировом рынке.

Стандарты комплекса ГОСТ 34 на создание и развитие автоматизированных систем (АС) – обобщенные, но воспринимаемые как весьма жесткие по структуре жизненного цикла (ЖЦ) и проектной документации. 

Наиболее популярными можно считать ГОСТ 34.601-90 (Автоматизированные системы. Стадии создания) и ГОСТ 34.602-89 (Техническое задание на создание АС). Введение единой, достаточно качественно определенной терминологии, наличие достаточно разумной классификации работ, документов, видов обеспечения и др. способствует более полной и качественной стыковке разных систем, что особенно важно в условиях, когда разрабатывается все больше сложных комплексных АС.

В последние годы в стране идет интенсивная работа по гармонизации государственных стандартов Российской Федерации с международными стандартами ISO в области создания нормативной базы управления жизненным циклом программных средств и информационных систем. В основе стандартизации - ГОСТ Р ИСО/МЭК 12207-99 "Информационная технология. Процессы жизненного цикла программных средств", который является аутентичным переводом международного стандарта ISO/IEC 12207: 1995-08-01.

Техническое задание (ТЗ) на АС - утвержденный в установленном порядке документ, определяющий цели, требования и основные исходные данные необходимые для разработки АС и содержащий предварительную оценку экономической эффективности. ТЗ содержит основные технические требования, предъявляемые к изделию и исходные данные для разработки;
в ТЗ указываются назначение объекта, область его применения, стадии разработки документации, её состав, сроки исполнения и т. д., а также особые требования, обусловленные спецификой самого объекта либо условиями его эксплуатации. Как правило, ТЗ составляют на основе анализа результатов, полученных в ходе предпроектного обследования.

Как инструмент коммуникации в связке общения заказчик-исполнитель, техническое задание позволяет:
А) Обеим сторонам:
 представить готовый продукт;
 выполнить проверку готового продукта по пунктам (приёмочное тестирование – проведение
испытаний);
 уменьшить число ошибок, связанных с изменением требований в результате их неполноты или
ошибочности (на всех стадиях и этапах создания, за исключением испытаний).
Б) Заказчику:
 осознать, что именно ему нужно, опираясь на существующие на данный момент технические
возможности и свои ресурсы;
 требовать от исполнителя соответствия продукта всем условиям, оговорённым в ТЗ.
В) Исполнителю:
 правильно понять суть задачи, показать заказчику «технический облик» будущего программного
изделия или АС;
 спланировать выполнение проекта и работать по намеченному плану;
 отказаться от выполнения работ, не указанных в ТЗ.

# Plant UML

## ER

```PlantUML
@startuml

skin rose

entity Клиент {
  * id : int
  --
  ФИО : varchar
  Телефон : varchar
  Адрес : varchar
}

entity Заказ {
  * id : int
  --
  Дата : date
  Сумма : decimal
  Статус : varchar
}

entity Услуга {
  * id : int
  --
  Название : varchar
  Описание : varchar
  Цена : decimal
}

entity Пользователь {
  * id : int
  --
  Логин : varchar
  Пароль : varchar
  Роль : varchar
}

Клиент ||--o{ Заказ : сделал
Заказ ||--|{ Услуга : включает
Пользователь ||--o{ Заказ : обработал
@enduml
```

# Диаграмма классов

```PlantUML
@startuml

skin rose

title Database design using UML Class Diagram and Entity Framework

class Customer {
  -Id : int
  -Name : string
  -Phone : string
  -Address : string
  +Orders : virtual ICollection<Order>
}

class User {
  -Id : int
  -Login : string
  -Password : string
  -Role : string
  +Orders : virtual ICollection<Order>
}

class Order {
  -Id : int
  -Date : DateTime
  -Amount : decimal
  -Status : string
  -CustomerId : int
  -UserId : int
  +Customer : virtual Customer
  +User : virtual User
  +Services : virtual ICollection<Service>
}

class Service {
  -Id : int
  -Name : string
  -Description : string
  -Price : decimal
  +Orders : virtual ICollection<Order>
}

class OrderService {
  -Id : int
  -OrderId : int
  -ServiceId : int
}

class GrandContext {
  +Customers : DbSet<Customer>
  +Users : DbSet<User>
  +Orders : DbSet<Order>
  +Services : DbSet<Service>
  +OrderServices : DbSet<OrderService>
}

Customer "1" -- "many" Order : contains
User "1" -- "many" Order : manages
Order "*" -- "*" Service : includes
OrderService "many" -- "1" Order : belongs to
OrderService "many" -- "1" Service : refers to

@enduml

```

## Диаграмма развертывания

```PlantUML
@startuml

skin rose

title Deployment diagram for application

node DatabaseServer {
  database Database <<SQL Server>>
}

node Client {
  artifact DesktopApp <<.NET MAUI>>
  component ViewModel <<MVVM>>
  component Model <<Entity Framework>>
}

Database ..> Model : connect
Model ..> ViewModel : use
DesktopApp ..> ViewModel : bind

@enduml

```

## Диаграмма пакетов MVVM

```PlantUML
@startuml

skin rose

title Package diagram for application

package GrandDatabase {
  class Customer
  class User
  class Order
  class Service
  class OrderService
}

package GrandContext {
  class GrandContext
}

package GrandApp {
  package ViewModels {
    class CustomerViewModel <<MVVM>>
    class UserViewModel <<MVVM>>
    class OrderViewModel <<MVVM>>
    class ServiceViewModel <<MVVM>>
  }
  package Views {
    interface ICustomerView
    interface IUserView
    interface IOrderView
    interface IServiceView
  }
}

GrandDatabase ..> GrandContext : use
GrandContext ..> ViewModels : use
ViewModels ..> Views : bind

@enduml

```

## Диаграмма вариантов использования

```PlantUML
@startuml
skin rose
left to right direction
skinparam packageStyle rectangle
actor Пользователь
actor Администратор
rectangle Приложение {
  Пользователь -- (Работать с клиентами)
  Пользователь -- (Работать с заказами)
  Пользователь -- (Работать с услугами)
  Администратор -- (Работать с клиентами)
  Администратор -- (Работать с заказами)
  Администратор -- (Работать с услугами)
  Администратор -- (Работать с пользователями)
}
@enduml

```

## Диаграмма деятельности

```PlantUML
@startuml

skin rose

start
:Пользователь выбирает клиента из списка;
:Пользователь выбирает услугу из списка;
:Пользователь вводит дату и сумму заказа;
:Пользователь нажимает кнопку "Создать заказ";
:Система проверяет корректность данных;
if (Данные корректны?) then (Да)
  :Система создает заказ и добавляет услугу в него;
  :Система отправляет уведомление пользователю;
else (Нет)
  :Система выводит сообщение об ошибке;
endif
stop
@enduml

```

## Диаграмма состояний

```PlantUML
@startuml

skin rose

[*] --> Новый
Новый --> Подтвержденный : Подтвердить
Подтвержденный --> Оплаченный : Оплатить
Оплаченный --> Закрытый : Закрыть
Закрытый --> [*]
@enduml

```

## Диаграмма деятельности

```PlantUML
@startuml

skin rose

title "Диаграмма последовательности"

actor User
boundary "Система"
database "База данных"
User -> "Система" : Ввести логин и пароль

activate "Система"
Система -> "База данных" : Проверить совпадение логина и пароля
activate "База данных"
"База данных" --> "Система" : Вернуть результат проверки
deactivate "База данных"
alt Проверка успешна
  Система --> Пользователь : Отправить сообщение "Авторизация успешна"
  Система -> Система : Открыть доступ к CRM системе
else Проверка неуспешна
  App --> Пользователь : Отправить сообщение "Неверный логин или пароль"
end
deactivate Система



@enduml
```
# Концептуальная модель данных

```PlantUML
@startuml
title Концептуальная модель данных
class Техника {
  +Номер
  +Модель
  +Тип
  +Год выпуска
}
class Неисправность {
  +Код
  +Описание
  +Дата обнаружения
  +Дата устранения
  +Стоимость ремонта
}
class Сотрудник {
  +Табельный номер
  +ФИО
  +Должность
  +Отдел
}
Техника "1" -- "0..*" Неисправность : имеет >
Неисправность "0..1" -- "1" Сотрудник : обнаружил >
Неисправность "0..1" -- "1" Сотрудник : устранил >
@enduml

```

# Логическая модель данных

```PlantUML
@startuml
title Логическая модель данных
!define table(x) class x << (T,#FFAAAA) >>
!define primary_key(x) <b>x</b>
!define foreign_key(x) <color:blue>x</color>
hide methods
hide stereotypes

table(Техника) {
  primary_key(Номер) int not null
  Модель varchar(50) not null
  Тип varchar(50) not null
  Год_выпуска int not null
}

table(Неисправность) {
  primary_key(Код) int not null identity(1,1)
  Описание varchar(200) not null
  Дата_обнаружения date not null
  Дата_устранения date null
  Стоимость_ремонта decimal(10,2) null
  foreign_key(Номер_техники) int not null
  foreign_key(Табельный_номер_обнаружившего) int not null
  foreign_key(Табельный_номер_устраняющего) int null
}

table(Сотрудник) {
  primary_key(Табельный_номер) int not null identity(1000,1)
  ФИО varchar(100) not null
  Должность varchar(50) not null
  Отдел varchar(50) not null
}

Техника ||--o{ Неисправность : Номер_техники (FK)
Сотрудник ||--o{ Неисправность : Табельный_номер_обнаружившего (FK)
Сотрудник ||--o{ Неисправность : Табельный_номер_устраняющего (FK)
@enduml

```

# Архитектура MVVM приложения

```PlantUML
@startuml
title Архитектура приложения
!define table(x) class x << (T,#FFAAAA) >>
!define view(x) class x << (V,#AAFFAA) >>
!define viewmodel(x) class x << (VM,#AAAAFF) >>
hide methods
hide stereotypes

table(Техника)
table(Неисправность)
table(Сотрудник)

view(AllNotesPage)
view(NotePage)
view(AboutPage)

viewmodel(AllNotesViewModel)
viewmodel(NoteViewModel)
viewmodel(AboutViewModel)

Техника "1" -- "0..*" Неисправность : имеет >
Неисправность "0..1" -- "1" Сотрудник : обнаружил >
Неисправность "0..1" -- "1" Сотрудник : устранил >

AllNotesPage ..> AllNotesViewModel : привязка данных
NotePage ..> NoteViewModel : привязка данных
AboutPage ..> AboutViewModel : привязка данных

AllNotesViewModel ..> Техника : использует
AllNotesViewModel ..> Неисправность : использует
NoteViewModel ..> Техника : использует
NoteViewModel ..> Неисправность : использует
NoteViewModel ..> Сотрудник : использует
AboutViewModel ..> About : использует

@enduml

```




